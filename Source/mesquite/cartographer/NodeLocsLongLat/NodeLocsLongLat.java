/* Mesquite.cartographer source code.  Copyright 2008-2009 D. Maddison and W. Maddison. Version 1.3, June 2008.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.cartographer.NodeLocsLongLat;/*~~  */import java.util.*;import java.awt.*;import java.awt.geom.Point2D;import mesquite.lib.*;import mesquite.lib.duties.*;import mesquite.cartographer.lib.*;import mesquite.cont.lib.*;/* ======================================================================== */public class NodeLocsLongLat extends TaxonLocsPlot {	Taxa taxa;	Tree tree;	boolean noMapImageShown = false;	boolean showCommandGiven = false;	Point2D.Double[] location;	String imagePath;	Image mapImage;	int margin = 0;	static final String prefVersionNumber = "0.99";//	NumbersForNodesIncr numbersForNodesTask;	LocationReconstructor reconstructorTask;	CharSourceCoordObed characterSourceTask;	ContinuousDistribution observedStates;	Taxa currentTaxa;	Double2DArray originalCoordinates, modifiedCoordinates;	TaxaDisplay taxaDisplay = null;	MesquiteString numberTaskName;	boolean veryFirstTime=true;	Vector extras;//	public MesquiteBoolean firstIsLatitude;   // if true, then the first character in the character source is the latitude, and the second is the longitude; otherwise it is the reverse.	protected MesquiteBoolean fadeMap;	private int mapWidth, mapHeight;	boolean hide = false;	boolean startedAsScripting;	protected MapProjection projectionTask;	MesquiteString projectionName;	MesquiteString reconstructorName;	MesquiteString characterSourceName;	MesquiteCommand ptC;	MesquiteCommand lrC;	MesquiteCommand csC;	MesquiteCommand nfntC;	MesquiteString addTaxaGroup = new MesquiteString("");	TaxaTool longLatTool;	MesquiteCommand touchMapCommand;	MesquiteCommand moveOverMapCommand;	MesquiteCommand moveOverTaxonCommand;	TaxaTool searchWebTool;	MesquiteCommand mouseUpSearchCommand;	MesquiteCommand taxonSearchCommand;	TaxaTool addTaxonTool;	MesquiteCommand mouseUpTaxonAddTaxonCommand;	MesquiteCommand mouseUpFieldAddTaxonCommand;	TaxaTool moveTaxonTool;	MesquiteCommand touchTaxonMoveTaxonCommand;	MesquiteCommand dragTaxonMoveTaxonCommand;	MesquiteCommand mouseUpMoveTaxonCommand;	protected URLLongLatServer URLTask;	MesquiteCommand[] chooseURLTaskCommands = null;	static String defaultURLTask = "#URLGoogleMaps";	boolean treePlot = true;	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed		EmployeeNeed e2 = registerEmployeeNeed(MapProjection.class, getName() + " needs a module to do the calculations for map projection.",		"The map projection calculator is chosen initially or using the Map Projection submenu");		EmployeeNeed e3 = registerEmployeeNeed(LocationReconstructor.class, getName() + " needs a module to reconstruction ancestral location.",		"The reconstructor is chosen initially or using the Ancestral Location Reconstructor submenu");		EmployeeNeed e4 = registerEmployeeNeed(CharSourceCoordObed.class, getName() + " needs a module to provide a source for the latitude and longitude data.",		"The character source is chosen initially or using the Character Source submenu");	}	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		makeMenu("Plot");		treePlot = !(getHiredAs()==TaxonLocsPlot.class);		if (arguments ==null)			projectionTask = (MapProjection)hireEmployee(MapProjection.class, "Map Projection");		else {			projectionTask = (MapProjection)hireNamedEmployee(MapProjection.class, arguments);			if (projectionTask == null)				projectionTask = (MapProjection)hireEmployee(MapProjection.class, "Map Projection");		}		if (projectionTask == null) {			return sorry(getName() + " couldn't start because no map projection was obtained.");		}		projectionTask.setOwnerModule(this);		projectionTask.setTreePlot(treePlot);		projectionTask.setMargin(margin);		ptC = makeCommand("setProjection",  this);		projectionTask.setHiringCommand(ptC);		projectionName = new MesquiteString();		projectionName.setValue(projectionTask.getName());		if (numModulesAvailable(MapProjection.class)>1){			MesquiteSubmenuSpec mss = addSubmenu(null, "Map Projection", ptC, MapProjection.class);			mss.setSelected(projectionName);		}		reconstructorTask = (LocationReconstructor)hireEmployee(LocationReconstructor.class, "Location Reconstructor");		if (reconstructorTask == null) {			return sorry(getName() + " couldn't start because no task for reconstructing ancestral location was obtained.");		}		reconstructorTask.setProjectionTask(projectionTask);		lrC = makeCommand("setReconstructor",  this);		reconstructorTask.setHiringCommand(lrC);		reconstructorName = new MesquiteString();		reconstructorName.setValue(reconstructorTask.getName());		if (numModulesAvailable(LocationReconstructor.class)>1){			MesquiteSubmenuSpec mss = addSubmenu(null, "Ancestral Location Reconstructor", lrC, LocationReconstructor.class);			mss.setSelected(reconstructorName);		}		// now get the longitude and latitude values		characterSourceTask = (CharSourceCoordObed)hireCompatibleEmployee(CharSourceCoordObed.class, GeographicState.class, "Source of latitude and longitude data");		if (characterSourceTask == null) {			return sorry(getName() + " couldn't start because no source of characters obtained.");		} 				csC = makeCommand("setCharacterSource",  this);		characterSourceTask.setHiringCommand(lrC);		characterSourceName = new MesquiteString();		characterSourceName.setValue(characterSourceTask.getName());		if (numModulesAvailable(CharSourceCoordObed.class)>1){			MesquiteSubmenuSpec mss = addSubmenu(null, "Character Source", csC, CharSourceCoordObed.class);			mss.setSelected(characterSourceName);		}		startedAsScripting = MesquiteThread.isScripting();		extras = new Vector();		/*		numbersForNodesTask= (NumbersForNodesIncr)hireEmployee(NumbersForNodesIncr.class, "Values to calculate for internal nodes for Plot Tree");		if (numbersForNodesTask == null )			return sorry(getName() + " couldn't start because no modules calculating numbers for nodes obtained.");		nfntC = makeCommand("setInternalNodeCalculator",  this);		numbersForNodesTask.setHiringCommand(nfntC);		numberTaskName = new MesquiteString(numbersForNodesTask.getName());		 */		//MesquiteSubmenuSpec xsub = addSubmenu(null, "Map");		addMenuItem("Choose Base Map...", makeCommand("setMap",  this));//		call this so that user can choose map//		firstIsLatitude = new MesquiteBoolean(true);//		addCheckMenuItem(null, "First Character is Latitude", makeCommand("toggleFirstLatitude",  this), firstIsLatitude);		fadeMap = new MesquiteBoolean(false);		addCheckMenuItem(null, "Fade Base Map", makeCommand("toggleFadeMap",  this), fadeMap);		longLatTool = new TreeTool(this, "longLat", getPath(), "longLatTool.gif", 8,8,"Latitude-Longitude Tool", "This tool allows you to examine the latitude and longitude of points on a map."); 		touchMapCommand = MesquiteModule.makeCommand("touchLongLat",  this);		longLatTool.setTouchedFieldCommand(touchMapCommand);		moveOverTaxonCommand = MesquiteModule.makeCommand("moveOverTaxonLongLat",  this);		longLatTool.setMoveOverTaxonCommand(moveOverTaxonCommand);		moveOverMapCommand = MesquiteModule.makeCommand("moveLongLat",  this);		longLatTool.setMovedCommand(moveOverMapCommand);		if (containerOfModule() instanceof MesquiteWindow) {			((MesquiteWindow)containerOfModule()).addTool(longLatTool);			//longLatTool.setPopUpOwner(this);		}		/*adding the search tool*/		if (defaultURLTask!=null) {			URLTask= (URLLongLatServer)hireNamedEmployee(URLLongLatServer.class, defaultURLTask);			if (URLTask == null)				URLTask = (URLLongLatServer)hireEmployee(URLLongLatServer.class, "Latitude Longitude URL Provider");  // just hire first one		}		else			URLTask = (URLLongLatServer)hireEmployee(URLLongLatServer.class, "Latitude Longitude URL Provider");  // just hire first one		if (URLTask!=null) {			searchWebTool = new TreeTool(this, "searchWeb", getPath(), "searchWebTool.gif", 3,3,"Search Web Tool", "This tool allows you to examine the points on a map in various web sites."); 			mouseUpSearchCommand = MesquiteModule.makeCommand("touchSearchWeb",  this);			searchWebTool.setMouseUpFieldCommand(mouseUpSearchCommand);			taxonSearchCommand = MesquiteModule.makeCommand("taxonSearchWeb",  this);			searchWebTool.setMouseUpTaxonCommand(taxonSearchCommand);			if (treePlot)				searchWebTool.setTouchedCommand(taxonSearchCommand);			if (containerOfModule() instanceof MesquiteWindow) {				((MesquiteWindow)containerOfModule()).addTool(searchWebTool);				searchWebTool.setPopUpOwner(this); //setOptionsChoiceCommand or something like that, build menus in doCommand				searchWebTool.setOptionsCommand(MesquiteModule.makeCommand("searchWebToolOptions", this));			} else return false;		}		/*adding the add and move taxon tools, only for the taxa window version*/		if (!treePlot) {			addTaxonTool = new TreeTool(this, "addTaxon", getPath(), "addTaxonTool.gif", 8,8,"Add Taxon Tool", "This tool allows you to add taxa to a map."); 			mouseUpFieldAddTaxonCommand = MesquiteModule.makeCommand("fieldAddTaxon",  this);			addTaxonTool.setMouseUpFieldCommand(mouseUpFieldAddTaxonCommand);			addTaxonTool.setIgnoreTaxa(true);			addTaxonTool.setOptionImageFileName("addTaxonToolOption.gif", 8, 8);			if (containerOfModule() instanceof MesquiteWindow) {				((MesquiteWindow)containerOfModule()).addTool(addTaxonTool);			} else return false;			moveTaxonTool = new TreeTool(this, "moveTaxon", getPath(), "moveTaxonTool.gif", 9,10,"Move Taxon Tool", "This tool allows you to move taxa to a map."); 			touchTaxonMoveTaxonCommand = MesquiteModule.makeCommand("touchMoveTaxon",  this);			moveTaxonTool.setTouchedTaxonCommand(touchTaxonMoveTaxonCommand);			mouseUpMoveTaxonCommand = MesquiteModule.makeCommand("mouseUpMoveTaxon",  this);			moveTaxonTool.setMouseUpTaxonCommand(mouseUpMoveTaxonCommand);			dragTaxonMoveTaxonCommand = MesquiteModule.makeCommand("dragMoveTaxon",  this);			moveTaxonTool.setDraggedTaxonCommand(dragTaxonMoveTaxonCommand);			if (containerOfModule() instanceof MesquiteWindow) {				((MesquiteWindow)containerOfModule()).addTool(moveTaxonTool);			} else return false;			checkToolValidity();		}		if (!MesquiteThread.isScripting()) {			loadOrChooseMap(null);			parametersChanged();		}		return true;	}	/*.................................................................................................................*/	public void processPreferencesFromFile (String[] prefs) {		if (prefs!=null && prefs.length>0) {			if (prefVersionNumber.equalsIgnoreCase(prefs[0])) {				defaultURLTask = prefs[1];			}		}	}	/*.................................................................................................................*/	public void setCursor(MesquiteCursor cursor) {		if (taxaDisplay!=null && cursor!=null)			taxaDisplay.setCursor(cursor.getCursor());			}	/*.................................................................................................................*/	public String preparePreferencesForXML () {		StringBuffer buffer = new StringBuffer();		StringUtil.appendXMLTag(buffer, 2, "defaultURLTask", defaultURLTask);  		return buffer.toString();	}	/*.................................................................................................................*/	public void processSingleXMLPreference (String tag, String content) {		if ("defaultURLTask".equalsIgnoreCase(tag))			defaultURLTask = StringUtil.cleanXMLEscapeCharacters(content);	}	/*.................................................................................................................*/	public GeographicData getGeographicData() {		observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,0);		if (observedStates==null)			return null;		GeographicData gData = (GeographicData)observedStates.getParentData();		return gData;	}	/*.................................................................................................................*/	/**  */	public void checkToolValidity(){ 		if (!treePlot) {			if (addTaxonTool!=null && moveTaxonTool!=null) {				addTaxonTool.setEnabled (getGeographicData() !=null && projectionTask != null && projectionTask.getFullySpecified());				moveTaxonTool.setEnabled (getGeographicData() !=null&& projectionTask != null && projectionTask.getFullySpecified());			}		}		if (searchWebTool!=null && projectionTask !=null) {			searchWebTool.setEnabled (projectionTask.getFullySpecified());		}		if (longLatTool!=null && projectionTask !=null) {			longLatTool.setEnabled (projectionTask.getFullySpecified());		}	}	/*.................................................................................................................*/	/** Returns the preferred size (if any) of the tree drawing.  Insert your own! */	public Dimension getPreferredSize(){ //		here return size requested (width, height).  If this changes, call parametersChanged() so employers can respond and request again the preferred size		return new Dimension(getMapWidth()+2*margin, getMapHeight()+2*margin);	}	/** Returns true if it will have a preferred size of the tree drawing */	public boolean hasPreferredSize(){		return true;	}	/*.................................................................................................................*/	/** Returns whether this is a tree plot or taxa plot */	public boolean getTreePlot(){ 		return treePlot;	}	/*.................................................................................................................*/	public void endJob(){		hide = true;		if (extras!=null) {			for (int i=0; i<extras.size(); i++){				if (treePlot) {					TreeDisplayExtra extra = (TreeDisplayExtra)extras.elementAt(i);					if (extra!=null){						TreeDisplay td = extra.getTreeDisplay();						extra.turnOff();						if (td!=null)							td.removeExtra(extra);					}				}				else {					TaxaDisplayExtra extra = (TaxaDisplayExtra)extras.elementAt(i);					if (extra!=null){						TaxaDisplay td = extra.getTaxaDisplay();						extra.turnOff();						if (td!=null)							td.removeExtra(extra);					}				}			}			extras.removeAllElements();		}		if (longLatTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(longLatTool);		if (searchWebTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(searchWebTool);		if (addTaxonTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(addTaxonTool);		if (moveTaxonTool!=null)			((MesquiteWindow)containerOfModule()).removeTool(moveTaxonTool);		super.endJob();	}	/*.................................................................................................................*/	public  Class getHireSubchoice(){		return MapProjection.class;	}	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/	public void initialize(Tree tree){		currentTaxa = tree.getTaxa();		this.tree = tree;		characterSourceTask.initialize(currentTaxa);	}	/*.................................................................................................................*/	public int getMargin(){		return margin;	}	/*.................................................................................................................*/	public boolean inMapField(int x, int y){		return (x>=getMargin() && x<= getMargin()+ getMapWidth() && y>=getMargin() && y<=getMargin()+getMapHeight());	}	/*.................................................................................................................*/	public MapProjection getProjectionTask(){		return projectionTask;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	public boolean getFadeMap(){		return fadeMap.getValue();	}	/*.................................................................................................................*/	public boolean showCitation(){		return true;	}	/*.................................................................................................................*/	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {		if (extras!=null) {			for (int i=0; i<extras.size(); i++){				if (!treePlot) {					NodeLocsLongLatTaxaExtra extra = (NodeLocsLongLatTaxaExtra)extras.elementAt(i);					if (extra!=null){						extra.pleaseAdjustScrolls=true;					}				}				else {					NodeLocsLongLatExtra extra = (NodeLocsLongLatExtra)extras.elementAt(i);					if (extra!=null){						extra.pleaseAdjustScrolls=true;					}				}			}		}		parametersChanged(notification);		checkToolValidity();	}	/*.................................................................................................................*/	public Image getMapImage() {		return mapImage;	}	/*.................................................................................................................*/	public int getMapHeight() {		if (!treePlot) {			NodeLocsLongLatTaxaExtra firstExtra = getFirstTaxaExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getHeight(firstExtra.getTaxaDisplay());		}		else {			NodeLocsLongLatExtra firstExtra = getFirstExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getHeight(firstExtra.getTreeDisplay());		}		return 200;	}	/*.................................................................................................................*/	public int getMapWidth() {		if (!treePlot) {			NodeLocsLongLatTaxaExtra firstExtra = getFirstTaxaExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getWidth(firstExtra.getTaxaDisplay());		}		else {			NodeLocsLongLatExtra firstExtra = getFirstExtra();			if (firstExtra!=null && mapImage!=null)				return mapImage.getWidth(firstExtra.getTreeDisplay());		}		return 200;	}	/*.................................................................................................................*/	public boolean loadOrChooseMap(String path) {		MesquiteString ms = new MesquiteString();		noMapImageShown = false;		Image image = null;		boolean canReplaceWithNoMapImage = true;		Component display = null;		if (!treePlot) {			NodeLocsLongLatTaxaExtra firstExtra = getFirstTaxaExtra();			if (firstExtra!=null)				display = firstExtra.getTaxaDisplay();		}		else {			NodeLocsLongLatExtra firstExtra = getFirstExtra();			if (firstExtra!=null)				display = firstExtra.getTreeDisplay();		}		if (display!=null) {			if (mapImage!=null) {   // we already have a map, which means this is being called to choose another one				image = MesquiteImage.loadImage("Choose  map:", null, display,  ms);				canReplaceWithNoMapImage = false;  // set this so that we don't replace with noMap image if image==null here because of user pressing cancel			}			else {    // we don't have a map, which means this just loads the image				image = MesquiteImage.loadImage("Choose map:", path, display,  ms);			}			((TaxaTreeDisplay)display).pleaseUpdate(false);		}		else {   // this is where you go if script stored in file, as you get to this before display is available.			image = MesquiteImage.loadImage("Choose map:", path, null,  ms);   			if (image==null && !StringUtil.blank(path))				alert("Map is not available in specified location, or it could not be read.");	 		    	 		}		if (image==null && canReplaceWithNoMapImage) {      // set map to noMap.gif			if (display!=null)				image = MesquiteImage.loadImage("Choose map:", getPath() + "noMap.gif", display,  ms);			else				image = MesquiteImage.loadImage("Choose map:", getPath() + "noMap.gif", null,  ms);			noMapImageShown = true;		}			if (ms!=null  && image!=null) {			mapImage = image;			imagePath = ms.getValue();			if (display !=null) 				((TaxaTreeDisplay)display).pleaseUpdate(false);			return true;		}		return false;		}	/*.................................................................................................................*/	/** Sets the map based upon the path information contained in "arguments".  	 */	public void setMap( String arguments) {  		imagePath = null;				imagePath = ParseUtil.getFirstToken(arguments, pos);   // get image path relative to data file		if (!StringUtil.blank(imagePath))			imagePath = MesquiteFile.composePath(getProject().getHomeDirectoryName(), imagePath);   // convert to full path		loadOrChooseMap(imagePath);  //now load map		if (!MesquiteThread.isScripting())			parametersChanged();	}	/*.................................................................................................................*/	/*.................................................................................................................*/	public NodeLocsLongLatTaxaExtra getFirstTaxaExtra(){		if (extras!=null) {			for (int i=0; i<extras.size(); i++){				NodeLocsLongLatTaxaExtra extra = (NodeLocsLongLatTaxaExtra)extras.elementAt(i);				if (extra!=null){					return extra;				}			}		}		return null;	}	/*.................................................................................................................*/	public NodeLocsLongLatExtra getFirstExtra(){		if (extras!=null) {			for (int i=0; i<extras.size(); i++){				NodeLocsLongLatExtra extra = (NodeLocsLongLatExtra)extras.elementAt(i);				if (extra!=null){					return extra;				}			}		}		return null;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine( "hide");		if (noMapImageShown)			temp.addLine("setMap ''");		else {			String s =  StringUtil.tokenize(MesquiteFile.decomposePath(getProject().getHomeDirectoryName(), imagePath));			temp.addLine("setMap " + s);		}		temp.addLine("toggleFadeMap " + fadeMap.toOffOnString());		temp.addLine("setProjection ", projectionTask); 		temp.addLine("setReconstructor ", reconstructorTask); 		temp.addLine( "setCharacterSource " , characterSourceTask);		if (URLTask!=null)			temp.addLine( "setURLTask " + StringUtil.tokenize(URLTask.getName()));		temp.addLine( "show");		return temp;	}	/*.................................................................................................................*/	public String searchWebURL(double longitude,double latitude){		if (URLTask==null)			return "";		double diff = projectionTask.getDiffLatitude()+projectionTask.getDiffLongitude();		URLTask.setRange(diff);		return URLTask.getURL(latitude, longitude,"");	}	/*.................................................................................................................*/	public void addTaxonToTaxaDisplays(){		hide = true;		if (extras!=null) {			for (int i=0; i<extras.size(); i++){				TaxaDisplayExtra extra = (TaxaDisplayExtra)extras.elementAt(i);				if (extra!=null){					TaxaDisplay td = extra.getTaxaDisplay();					if (td!=null)						td.getTaxaDrawing().addOneTaxon();				}			}		}	}	/*.................................................................................................................*/	public void addTaxon(MesquiteString taxonName, MesquiteNumber latitude, MesquiteNumber longitude){		int it = taxa.getNumTaxa()-1;		taxa.addTaxa(it, 1, true);		it = taxa.getNumTaxa()-1;		if (taxonName!=null && !StringUtil.blank(taxonName.toString()))			taxa.setTaxonName(it, taxonName.toString(), false); 		if (!StringUtil.blank(addTaxaGroup.toString())) {			TaxaPartition currentGroups = (TaxaPartition)taxa.getCurrentSpecsSet(TaxaPartition.class);			TaxaGroupVector groups = (TaxaGroupVector)getProject().getFileElement(TaxaGroupVector.class, 0);			Object  obj = groups.getElement(addTaxaGroup.toString());			TaxaGroup tg = (TaxaGroup)obj;			if (tg==null)				tg = TaxaGroup.makeGroup(this,addTaxaGroup.toString(), taxa, groups);			if (tg!=null) {				if (currentGroups==null) {					currentGroups= new TaxaPartition("Untitled Partition", taxa.getNumTaxa(), null, taxa);					currentGroups.addToFile(taxa.getFile(), getProject(), findElementManager(TaxaPartition.class));					taxa.setCurrentSpecsSet(currentGroups, TaxaPartition.class);				}				if (currentGroups!=null)					currentGroups.setProperty(tg, it);			}		}		GeographicData gData = getGeographicData();		if (gData!=null) {			gData.setState(gData.getLongitudeCharacter(), it, 0, longitude.getDoubleValue());			gData.setState(gData.getLatitudeCharacter(), it, 0, latitude.getDoubleValue());			parametersChanged();		}	}	/*.................................................................................................................*/	private boolean getLatLongFromArguments(String arguments, MesquiteNumber latitude, MesquiteNumber longitude) {		// this only works if first two items in arguments are the x and y coordinates		MesquiteInteger io = new MesquiteInteger(0);		MesquiteNumber x= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));		MesquiteNumber y= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));		if (inMapField((int)(x.getIntValue()/taxaDisplay.getRescaleValue()),(int)(y.getIntValue()/taxaDisplay.getRescaleValue()))) { 			if (projectionTask.convertScreenToLongLat(x,y,longitude,latitude))				return true;		}		return false;	}	/*.................................................................................................................*/	MesquiteInteger pos = new MesquiteInteger();	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		/*    	 	 if (checker.compare(this.getClass(), "Sets the module that calculates coordinates for the nodes", "[name of module]", commandName, "setInternalNodeCalculator")) {    	 		NumbersForNodesIncr temp =  (NumbersForNodesIncr)replaceEmployee(NumbersForNodesIncr.class, arguments, "Value for axes", numbersForNodesTask); 			if (temp!=null) { 				numbersForNodesTask = temp;				numbersForNodesTask.setHiringCommand(nfntC);				numberTaskName.setValue(numbersForNodesTask.getName());				resetContainingMenuBar(); 				parametersChanged(); 			} 			return temp;    	 	}   	 	else		 */      	 			if (checker.compare(this.getClass(), "Sets the map projection", "[name of module]", commandName, "setProjection")) {			MapProjection temp = (MapProjection)replaceEmployee(MapProjection.class, arguments, "Map Projection", projectionTask);			if (temp !=null){				projectionTask = temp;				projectionName.setValue(projectionTask.getName());				projectionTask.setHiringCommand(ptC);				projectionTask.setMargin(margin);				projectionTask.setOwnerModule(this);				reconstructorTask.setProjectionTask(projectionTask);				parametersChanged();				return projectionTask;			}		}		else  if (checker.compare(this.getClass(), "Sets the ancestral location reconstructor.", "[name of module]", commandName, "setReconstructor")) {			LocationReconstructor temp = (LocationReconstructor)replaceEmployee(LocationReconstructor.class, arguments, "Ancestral Location Reconstructor", reconstructorTask);			if (temp !=null){				reconstructorTask = temp;				reconstructorName.setValue(reconstructorTask.getName());				reconstructorTask.setHiringCommand(lrC);				reconstructorTask.setProjectionTask(projectionTask);				parametersChanged();				return reconstructorTask;			}		}		else if (checker.compare(this.getClass(), "Sets whether or not the map is shown faded.", "[on = fade; off]", commandName, "toggleFadeMap")) {			fadeMap.toggleValue(parser.getFirstToken(arguments));			parametersChanged();		}		else if (checker.compare(this.getClass(), "Set the URL task", "[module name]", commandName, "setURLTask")) {			URLLongLatServer temp=  (URLLongLatServer)replaceEmployee(URLLongLatServer.class, arguments, "URL Provider", URLTask);			if (temp!=null)				URLTask= temp;			if (searchWebTool!=null)				searchWebTool.setEnabled(URLTask!=null);			return URLTask;		}		else if (checker.compare(this.getClass(), "Present the popup menu to select options for search web tool", null, commandName, "searchWebToolOptions")) {			if (searchWebTool == null)				return null;			MesquiteButton button = searchWebTool.getButton();			if (button!=null){				MesquiteInteger io = new MesquiteInteger(0);				int x= MesquiteInteger.fromString(arguments, io); //getting x and y from arguments				int y= MesquiteInteger.fromString(arguments, io);				MesquitePopup popup = new MesquitePopup(button);				Listable[] moduleList = MesquiteTrunk.mesquiteModulesInfoVector.getModulesOfDuty(URLLongLatServer.class, null, this);				for (int i=0; i<moduleList.length; i++) {					MesquiteModuleInfo m = (MesquiteModuleInfo)moduleList[i];					MesquiteCommand mc = makeCommand("setURLTask", this);					mc.setDefaultArguments(StringUtil.tokenize(m.getName()));					MesquiteCheckMenuItem mItem = new MesquiteCheckMenuItem(m.getName(), this, mc, null, null);					if (URLTask!=null)						mItem.set(URLTask.getName().equalsIgnoreCase(m.getName()));					popup.add(mItem);				}				popup.showPopup(x,y+6);			}		}		else if (checker.compare(this.getClass(), "Sets module supplying characters", null, commandName, "setCharacterSource")) {			CharSourceCoordObed temp = (CharSourceCoordObed)replaceCompatibleEmployee(CharSourceCoordObed.class, arguments, characterSourceTask, GeographicState.class);			if (temp !=null){				characterSourceTask = temp;				characterSourceName.setValue(characterSourceTask.getName());				characterSourceTask.setHiringCommand(csC);				parametersChanged();				return characterSourceTask;			}		}    	 			else if (checker.compare(this.getClass(), "Returns module supplying characters", null, commandName, "getCharacterSource")) {			return characterSourceTask;		}    	 			else if (checker.compare(this.getClass(), "Returns module supplying URL", null, commandName, "getURLTask")) {			return URLTask;		}    	 			else if (checker.compare(this.getClass(), "Hides the plot", null, commandName, "hide")) {			hide = true;		}		else if (checker.compare(this.getClass(), "Shows the plot", null, commandName, "show")) {			hide = false;			showCommandGiven = true;		}		else if (checker.compare(this.getClass(), "Chooses map for the treewindow background", null, commandName, "setMap")) {			setMap(arguments);		}		else if (checker.compare(this.getClass(), "Sets the coordinates.", null, commandName, "setCoordinates")) {			/*    	 		int ic = CharacterStates.toInternal(MesquiteInteger.fromString(arguments)); 			latitudeCharacter = ic; 			numbersForNodesTask.setCurrent(ic); 			if (!MesquiteThread.isScripting()) 				parametersChanged();			 */		}		else if (checker.compare(this.getClass(), "Long Lat tool has been touched", "[x coordinate][y coordinate]", commandName, "touchLongLat")) {			if (!projectionTask.getFullySpecified()) {			}			else {				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (getLatLongFromArguments(arguments, latitude, longitude)){				}			}		}		else if (checker.compare(this.getClass(), "Long Lat tool has been moved", "[x coordinate][y coordinate]", commandName, "moveLongLat")) {			if (!projectionTask.getFullySpecified()) {				if (containerOfModule() instanceof MesquiteWindow) {					((MesquiteWindow)containerOfModule()).setExplanation("Longitude and latitude not calculable as the projection is not yet fully calibrated.");				}				}			else {				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (getLatLongFromArguments(arguments, latitude, longitude)){					if (containerOfModule() instanceof MesquiteWindow) {						if (longitude.isCombinable() && latitude.isCombinable())							((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude.getDoubleValue(),projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude.getDoubleValue(),projectionTask.getLatPrecision()) );						else							((MesquiteWindow)containerOfModule()).setExplanation("");					}					}			}		}		else if (checker.compare(this.getClass(), "Search Web tool has been touched on the field.", "[x coordinate][y coordinate]", commandName, "touchSearchWeb")) {			if (!projectionTask.getFullySpecified()) {				sorry("The Search Web tool cannot be used as the projection is not yet fully calibrated.");			}			else {				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (getLatLongFromArguments(arguments, latitude, longitude)){					if (containerOfModule() instanceof MesquiteWindow) {						if (longitude.isCombinable() && latitude.isCombinable()) {							((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude.getDoubleValue(),projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude.getDoubleValue(),projectionTask.getLatPrecision()) );							MesquiteModule.showWebPage(searchWebURL(longitude.getDoubleValue(), latitude.getDoubleValue()), true);						} else							((MesquiteWindow)containerOfModule()).setExplanation("");					}					}			}		}		else if (checker.compare(this.getClass(), "Add Taxon tool has been touched on the field.", "[x coordinate][y coordinate]", commandName, "fieldAddTaxon")) {			MesquiteNumber longitude = new MesquiteNumber();				MesquiteNumber latitude = new MesquiteNumber();				boolean optionDown = arguments.indexOf("option")>=0;			if (getLatLongFromArguments(arguments, latitude, longitude)){				if (containerOfModule() instanceof MesquiteWindow && longitude.isCombinable()&& latitude.isCombinable()) {					if (!optionDown) {						MesquiteInteger buttonPressed = new MesquiteInteger(-1);						MesquiteString taxonName = new MesquiteString("");						if (!MesquiteThread.isScripting()) {							NewTaxonDialog dialog = new NewTaxonDialog(this,buttonPressed,taxonName, addTaxaGroup);						}						if (buttonPressed.getValue()==0) 							addTaxon(taxonName, latitude, longitude);					}					else						addTaxon(null, latitude, longitude);				}				}		}		else if (checker.compare(this.getClass(), "Move Taxon tool has been touched on a taxon.", "[taxon][modifiers]", commandName, "touchMoveTaxon")) {			MesquiteInteger io = new MesquiteInteger(0);			int it = MesquiteInteger.fromString(arguments, io);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLongitudeCharacter());			double longitude = observedStates.getState(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLatitudeCharacter());			double latitude = observedStates.getState(it);			if (containerOfModule() instanceof MesquiteWindow) {				if ( MesquiteDouble.isCombinable(longitude) && MesquiteDouble.isCombinable(latitude))					((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude,projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude,projectionTask.getLatPrecision()) );				else					((MesquiteWindow)containerOfModule()).setExplanation("");			}			}		else if (checker.compare(this.getClass(), "Move Taxon tool has been dragged.", "[branch number] [x coordinate dragged] [y coordinate dragged] ", commandName, "dragMoveTaxon")) {			MesquiteInteger io = new MesquiteInteger(0);			int it= MesquiteInteger.fromString(arguments, io);			MesquiteNumber x= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			MesquiteNumber y= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			if (inMapField(x.getIntValue(),y.getIntValue())) { 				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (projectionTask.convertScreenToLongLat(x,y,longitude,latitude)) {					if (containerOfModule() instanceof MesquiteWindow)  {						if (longitude.isCombinable()&& latitude.isCombinable())							((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude.getDoubleValue(),projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude.getDoubleValue(),projectionTask.getLatPrecision()) );						else							((MesquiteWindow)containerOfModule()).setExplanation("");//						moveDot();					}					}				}		}		else if (checker.compare(this.getClass(), "LongLat tool has been moved over a taxon.", "[taxon] [modifiers] ", commandName, "moveOverTaxonLongLat")) {			MesquiteInteger io = new MesquiteInteger(0);			int it = MesquiteInteger.fromString(arguments, io);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLongitudeCharacter());			double longitude = observedStates.getState(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLatitudeCharacter());			double latitude = observedStates.getState(it);			if (containerOfModule() instanceof MesquiteWindow) {				if ( MesquiteDouble.isCombinable(longitude) && MesquiteDouble.isCombinable(latitude))					((MesquiteWindow)containerOfModule()).setExplanation("Taxon " + taxa.getTaxonName(it) + ".    Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude,projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude,projectionTask.getLatPrecision()) );				else					((MesquiteWindow)containerOfModule()).setExplanation("");			}			}		else if (checker.compare(this.getClass(), "Move Taxon tool has been let go.", "[branch number] [x coordinate dropped] [y coordinate dropped] ", commandName, "mouseUpMoveTaxon")) {			MesquiteInteger io = new MesquiteInteger(0);			int it= MesquiteInteger.fromString(arguments, io);			MesquiteNumber x= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			MesquiteNumber y= new MesquiteNumber(MesquiteInteger.fromString(arguments, io));			if (inMapField(x.getIntValue(),y.getIntValue())) { 				MesquiteNumber longitude = new MesquiteNumber();					MesquiteNumber latitude = new MesquiteNumber();					if (projectionTask.convertScreenToLongLat(x,y,longitude,latitude)) {					if (containerOfModule() instanceof MesquiteWindow && longitude.isCombinable()&& latitude.isCombinable()) {//						eraseDot(oldX,oldY);						GeographicData gData = getGeographicData();						if (gData!=null) {							gData.setState(gData.getLongitudeCharacter(), it, 0, longitude.getDoubleValue());							gData.setState(gData.getLatitudeCharacter(), it, 0, latitude.getDoubleValue());							parametersChanged();						}					}					}				}		}		else if (checker.compare(this.getClass(), "Search Web tool has been touched on a taxon.", "[taxon][x][y][modifiers]", commandName, "taxonSearchWeb")) {			MesquiteInteger io = new MesquiteInteger(0);			int it = MesquiteInteger.fromString(arguments, io);			if (treePlot && tree !=null)				it = tree.taxonNumberOfNode(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLongitudeCharacter());			double longitude = observedStates.getState(it);			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa,GeographicData.getLatitudeCharacter());			double latitude = observedStates.getState(it);			if (containerOfModule() instanceof MesquiteWindow ) {				if (MesquiteDouble.isCombinable(longitude) && MesquiteDouble.isCombinable(latitude)) {					((MesquiteWindow)containerOfModule()).setExplanation("Longitude: " + MesquiteDouble.toPrecisionSpecifiedString(longitude,projectionTask.getLongPrecision()) + ", latitude: " + MesquiteDouble.toPrecisionSpecifiedString(latitude,projectionTask.getLatPrecision()) );					MesquiteModule.showWebPage(searchWebURL(longitude, latitude), true);				} else					((MesquiteWindow)containerOfModule()).setExplanation("" );			}			}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	/*   	 private void adjustScrolls(){  	 	if (extras!=null) {	   		for (int i=0; i<extras.size(); i++){	   			NodeLocsLongLatExtra extra = (NodeLocsLongLatExtra)extras.elementAt(i);	   		}  	 	}   	 }	 */	public String getName() {		return "Plot on Map";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Calculates the node locations on a map." ;	}	/*.................................................................................................................*/	/** returns the version number at which this module was first released.  If 0, then no version number is claimed.  If a POSITIVE integer	 * then the number refers to the Mesquite version.  This should be used only by modules part of the core release of Mesquite.	 * If a NEGATIVE integer, then the number refers to the local version of the package, e.g. a third party package*/	public int getVersionOfFirstRelease(){		return -100;  	}	/*_________________________________________________*/	public boolean compatibleWithOrientation(int orientation) {		return false;	}		public double getRescaleValue() {		if (taxaDisplay==null)			return 1.0;		return (1.0*taxaDisplay.getFieldWidth())/getMapWidth();	}	public int getRescaleOffset() {		return margin;	}	/*_________________________________________________*/	public void calculateTaxonLocs(TaxaDisplay taxaDisplay, Taxa taxa, Rectangle rect) {		this.taxa = taxa;		if (hide || isDoomed())			return;		if (taxaDisplay == null || taxaDisplay.getTaxaDrawing() == null)			return;		this.taxaDisplay = taxaDisplay;		if (veryFirstTime) {			veryFirstTime=false;//			numbersForNodesTask.initialize(tree);		}//		................  get Extra for drawing the map ........		NodeLocsLongLatTaxaExtra extra = null;		if (taxaDisplay.getExtras() !=null) {			if (taxaDisplay.getExtras().myElements(this)==null) {  				extra = new NodeLocsLongLatTaxaExtra(this, taxaDisplay); 				taxaDisplay.addExtra(extra); 				extras.addElement(extra);			}			else {				Listable[] mine = taxaDisplay.getExtras().myElements(this);				if (mine !=null && mine.length>0)					extra =(NodeLocsLongLatTaxaExtra) mine[0];			}		}		int mapWidth2 =  getMapWidth();		//mapHeight = getMapHeight();		mapWidth =  taxaDisplay.getFieldWidth();  		mapHeight = taxaDisplay.getFieldHeight();				double rescale = getRescaleValue();		double offset = getRescaleOffset();		MesquiteBoolean illegalValue = new MesquiteBoolean(false);		projectionTask.setTaxaDisplay(taxaDisplay);		if (projectionTask.getFullySpecified()) {			//projectionTask.setMapSize(taxaDisplay.getFieldHeight(),  taxaDisplay.getFieldWidth());			projectionTask.setMapSize(mapHeight,  mapWidth);			// ................  init the storage for the locations ........			int taxadn = taxaDisplay.getNumTaxa();			int taxan = taxa.getNumTaxa();			location = new Point2D.Double[taxaDisplay.getNumTaxa()];   //this will store the location values for all of the nodes			for (int i=0; i<location.length; i++) {				location[i]= new Point2D.Double();			}			NumberArray numbersX= new NumberArray(taxa.getNumTaxa());			NumberArray numbersY=new NumberArray(taxa.getNumTaxa());			/*				There are three coordinate systems:					- long/lat					- projected  (is of the final shape of the sceen image but is not scaled to fit on screen and some offsets need to be applied					- screen			 */			projectionTask.calcProjectionScalesAndOffsets();			// ................  get raw long lats and put into arrays ........			originalCoordinates = new Double2DArray(2,taxa.getNumTaxa());			modifiedCoordinates = new Double2DArray(2,taxa.getNumTaxa());			observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa, GeographicData.getLongitudeCharacter());			for (int it = 0; it<taxa.getNumTaxa(); it++) {				originalCoordinates.setValue(0,it, observedStates.getState(it));				modifiedCoordinates.setValue(0,it, observedStates.getState(it));			}							observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(taxa, GeographicData.getLatitudeCharacter());			for (int it = 0; it<taxa.getNumTaxa(); it++) {				originalCoordinates.setValue(1,it,observedStates.getState(it));				modifiedCoordinates.setValue(1,it,observedStates.getState(it));			}							MesquiteNumber x = new MesquiteNumber();			MesquiteNumber y = new MesquiteNumber();			double longitude;			double latitude;			// ................  reset the "original" locations to be the calculated ones, so that they can be used in reconstruction of internal nodes ........			for (int it = 0; it<taxa.getNumTaxa(); it++) {				longitude = modifiedCoordinates.getValue(0,it);				latitude = modifiedCoordinates.getValue(1,it);				projectionTask.convertLongLatsToScreenCoordinates (longitude,  latitude,  x,  y, illegalValue);				if (location!=null && it >=0 &&  it<location.length && x!=null && y!=null) {					location[it].x = x.getDoubleValue();					location[it].y = y.getDoubleValue();				}			}							// ................  various clean up things			for (int i=0; i<taxa.getNumTaxa() && i<taxaDisplay.getTaxaDrawing().y.length; i++) {				taxaDisplay.getTaxaDrawing().y[i] = (location[i].y);				taxaDisplay.getTaxaDrawing().x[i] = (int)(location[i].x);			}			// ................ rescale			//for (int i=0; i<taxa.getNumTaxa() && i<taxaDisplay.getTaxaDrawing().y.length; i++) {			//	taxaDisplay.getTaxaDrawing().y[i] = (int)((taxaDisplay.getTaxaDrawing().y[i]-margin)*rescale) + margin;			//	taxaDisplay.getTaxaDrawing().x[i] = (int)((taxaDisplay.getTaxaDrawing().x[i]-margin)*rescale) + margin;			//}		}		else {			for (int i=0; i<taxa.getNumTaxa() && i<taxaDisplay.getTaxaDrawing().y.length; i++) {				taxaDisplay.getTaxaDrawing().y[i] = margin;				taxaDisplay.getTaxaDrawing().x[i] = margin;			}		}		if (illegalValue.getValue())			if (extra!=null)				extra.addWarning(false);	}	/*_________________________________________________*/	public void calculateNodeLocs(TreeDisplay treeDisplay, Tree tree, int drawnRoot, Rectangle rect) {		if (hide || isDoomed())			return;		boolean doInternals = true;		if (tree!=null) {			this.tree =  tree;//			tree = new MesquiteTree(taxa);			//((MesquiteTree)tree).setToDefaultBush(tree.getNumTaxa(), false);		}		if (MesquiteTree.OK(tree)) {			if (treeDisplay == null || treeDisplay.getTreeDrawing() == null)				return;			if (veryFirstTime) {				veryFirstTime=false;//				numbersForNodesTask.initialize(tree);				// here initialize reconstructorTask?			}			// ................  get Extra for drawing the map ........			NodeLocsLongLatExtra extra = null;			if (treeDisplay.getExtras() !=null) {				if (treeDisplay.getExtras().myElements(this)==null) {  					extra = new NodeLocsLongLatExtra(this, treeDisplay); 					treeDisplay.addExtra(extra); 					extras.addElement(extra);				}				else {					Listable[] mine = treeDisplay.getExtras().myElements(this);					if (mine !=null && mine.length>0)						extra =(NodeLocsLongLatExtra) mine[0];				}			}			mapWidth = getMapWidth();			mapHeight = getMapHeight();			MesquiteBoolean illegalValue = new MesquiteBoolean(false);			projectionTask.setTreeDisplay(treeDisplay);			if (projectionTask.getFullySpecified()) {								projectionTask.setMapSize(mapHeight,  mapWidth);				// ................  init the storage for the locations ........				int subRoot = tree.motherOfNode(drawnRoot);				location = new Point2D.Double[tree.getNumNodeSpaces()];   //this will store the location values for all of the nodes				for (int i=0; i<location.length; i++) {					location[i]= new Point2D.Double();				}				NumberArray numbersX= new NumberArray(tree.getNumNodeSpaces());				NumberArray numbersY=new NumberArray(tree.getNumNodeSpaces());				/*						There are three coordinate systems:							- long/lat							- projected  (is of the final shape of the sceen image but is not scaled to fit on screen and some offsets need to be applied							- screen				 */				projectionTask.calcProjectionScalesAndOffsets();				// ................  get raw long lats and put into arrays ........				originalCoordinates = new Double2DArray(2,tree.getNumNodeSpaces());				modifiedCoordinates = new Double2DArray(2,tree.getNumNodeSpaces());				observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(tree,GeographicData.getLongitudeCharacter());				for (int it = 0; it<tree.getNumTaxa(); it++) {					originalCoordinates.setValue(0,tree.nodeOfTaxonNumber(it), observedStates.getState(it));					modifiedCoordinates.setValue(0,tree.nodeOfTaxonNumber(it), observedStates.getState(it));				}								observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(tree, GeographicData.getLatitudeCharacter());				for (int it = 0; it<tree.getNumTaxa(); it++) {					originalCoordinates.setValue(1,tree.nodeOfTaxonNumber(it),observedStates.getState(it));					modifiedCoordinates.setValue(1,tree.nodeOfTaxonNumber(it),observedStates.getState(it));				}								/* ................  converts terminal node long lats into projected coordinates, and stores results in originalCoordinates array, 						with modifiedCoordinates[0][it] being X ........ 						and modifiedCoordinates[1][it] being Y .......						This isn't the actual screen coordinates, just the virtual, unscaled, unshifted coordinates				 */				projectionTask.convertLongLatsToProjected(tree,drawnRoot,modifiedCoordinates, illegalValue, false);				if (illegalValue.getValue())					doInternals = false;				// ................  sets location, in screen coordinates, of terminal nodes.  Will be stored in the location array ........				projectionTask.convertProjectedToScreenCoordinates(tree, drawnRoot, modifiedCoordinates, false);				// ................  reconstruct position of internal nodes ........				if (doInternals) {					double[][]  reconstructed  = reconstructorTask.reconstructLocations(tree, originalCoordinates, modifiedCoordinates); 					for (int node = 0; node<tree.getNumNodeSpaces(); node++) {						if (!tree.nodeIsTerminal(node)) {							modifiedCoordinates.setValue(0,node, reconstructed[0][node]);							modifiedCoordinates.setValue(1,node, reconstructed[1][node]);						}					}						// ................  reset the "original" locations to be the calculated ones, so that they can be used in reconstruction of internal nodes ........					for (int node = 0; node<tree.getNumNodeSpaces(); node++) {						location[node].x = modifiedCoordinates.getValue(0,node);						location[node].y = modifiedCoordinates.getValue(1,node);					}									// ................  various clean up things					location[subRoot].x = location[drawnRoot].x;					location[subRoot].y = location[drawnRoot].y;					for (int i=0; i<tree.getNumNodeSpaces() && i<treeDisplay.getTreeDrawing().y.length; i++) {						treeDisplay.getTreeDrawing().y[i] = location[i].y;						treeDisplay.getTreeDrawing().x[i] = location[i].x;					}				} 				else {					// ................  reset the "original" locations to be the calculated ones, so that they can be used in reconstruction of internal nodes ........					for (int node = 0; node<tree.getNumNodeSpaces(); node++) {						if (tree.nodeIsTerminal(node)) {							location[node].x = modifiedCoordinates.getValue(0,node);							location[node].y = modifiedCoordinates.getValue(1,node);						}					}									// ................  various clean up things					for (int i=0; i<tree.getNumNodeSpaces() && i<treeDisplay.getTreeDrawing().y.length; i++) 						if (tree.nodeIsTerminal(i)) {							treeDisplay.getTreeDrawing().y[i] = location[i].y;							treeDisplay.getTreeDrawing().x[i] = location[i].x;						}				}			}			if (illegalValue.getValue() || !projectionTask.getFullySpecified())				if (doInternals) {					for (int i=0; i<tree.getNumNodeSpaces() && i<treeDisplay.getTreeDrawing().y.length; i++) {						treeDisplay.getTreeDrawing().y[i] = margin;						treeDisplay.getTreeDrawing().x[i] = margin;						treeDisplay.getTreeDrawing().z[i] = margin;					}					if (extra!=null)						extra.addWarning(true);					return;				} //else			//discreetAlert("Some longitude latitude values are illegal (perhaps missing data), and were not plotted");			if (extra!=null)				extra.addWarning(false);		}	}	/*.................................................................................................................*/	void nodePositions(int N,  Tree tree, StringBuffer sb, NumberArray numbersX, NumberArray numbersY) {		for (int d = tree.firstDaughterOfNode(N); tree.nodeExists(d); d = tree.nextSisterOfNode(d))			nodePositions(d, tree, sb, numbersX, numbersY);		if (tree.nodeIsTerminal(N))			sb.append(tree.getTaxa().getName(tree.taxonNumberOfNode(N)) + '\t');		else			sb.append("node " + N +  '\t');		sb.append(numbersX.toString(N) + '\t' + numbersY.toString(N) + "\n");	}	/*.................................................................................................................*/	private void drawString(Graphics g, String s, int x, int y){		if (g == null || StringUtil.blank(s))			return;		try {			g.drawString(s, x, y);		}		catch (Exception e){		}	}	/*.................................................................................................................*/	public void drawExtras (Graphics g,TreeDisplay treeDisplay) {		projectionTask.setMapSize(getMapHeight(), getMapWidth());		projectionTask.drawExtras(g,treeDisplay);	}	/*.................................................................................................................*/	public void drawTaxaExtras (Graphics g,TaxaDisplay taxaDisplay) {		projectionTask.setMapSize(getMapHeight(), getMapWidth());		projectionTask.drawTaxaExtras(g,taxaDisplay);	}}/*=======================================================================*/class NewTaxonDialog extends ExtensibleDialog  {	NodeLocsLongLat ownerModule;	public NewTaxonDialog (NodeLocsLongLat ownerModule, MesquiteInteger buttonPressed, MesquiteString taxonName, MesquiteString group){		super(ownerModule.containerOfModule(), "New Taxon", buttonPressed);		this.ownerModule = ownerModule;		addLabel("New Taxon", Label.CENTER);		SingleLineTextField textField = addTextField("Name: ", "", 20);		ListableVector groupList = (ListableVector)ownerModule.getProject().getFileElement(TaxaGroupVector.class,0);		int numGroups = groupList.getNumberOfParts();		String[] groups = new String[numGroups+1];		groups[0] = "(no group)";		for (int i = 1; i<numGroups+1; i++)			groups[i] = groupList.nameOfElementAt(i-1);		Choice groupPopUp=null;		if (groups!=null) {			groupPopUp = addPopUpMenu("Group: ", groups, 0);			if (!StringUtil.blank(group.getValue()))				groupPopUp.select(group.getValue());		}		completeAndShowDialog("Create", "Cancel",true,null);		int button = query();		if (buttonPressed!=null)			buttonPressed.setValue(button);		if (button==0) {			if (groupPopUp!=null) {				int groupValue = groupPopUp.getSelectedIndex();				if (groupValue>0) 					group.setValue(groupPopUp.getSelectedItem());				else					group.setValue("");			}			taxonName.setValue(textField.getText());		}		dispose();	}}/* ======================================================================== */class NodeLocsLongLatExtra extends TreeDisplayBkgdExtra {	NodeLocsLongLat ownerModule;	public boolean pleaseAdjustScrolls = false;	public String parameters = "";	StringBuffer textPositions;	public NodeLocsLongLatExtra (NodeLocsLongLat ownerModule, TreeDisplay treeDisplay) {		super(ownerModule, treeDisplay);		this.ownerModule = ownerModule;		textPositions = new StringBuffer();		setPlacement(BELOW);//		Image mapImage = ownerModule.getMapImage();//		if (mapImage !=null)//		treeDisplay.setPreferredSize(ownerModule.getMapImage().getWidth(treeDisplay)+ownerModule.getMargin(), ownerModule.getMapImage().getHeight(treeDisplay)+ownerModule.getMargin());	}	/*_________________________________________________*/	public   void drawImage(TreeDisplay treeDisplay, Tree tree, int drawnRoot, Graphics g) {		if (MesquiteTree.OK(tree)) {	 		Composite composite = null;			if (ownerModule.getFadeMap()){		 		composite = ColorDistribution.getComposite(g);				ColorDistribution.setTransparentGraphics(g);			}			g.drawImage(ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(), Color.white, null);			if (ownerModule.getFadeMap())				ColorDistribution.setComposite(g,composite);					if (!ownerModule.getProjectionTask().getFullySpecified()) {				Font f = g.getFont();				if (f!=null){					Font fontToSet = new Font (f.getName(), Font.BOLD,32);					if (fontToSet!= null) {						g.setFont(fontToSet);						g.setColor(Color.black);						g.drawString("Uncalibrated Projection", ownerModule.getMargin()+7, ownerModule.getMargin()+62);						g.setColor(Color.red);						g.drawString("Uncalibrated Projection", ownerModule.getMargin()+5, ownerModule.getMargin()+60);						GraphicsUtil.setFontSize(14,g);						g.setColor(Color.white);						g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+7, ownerModule.getMargin()+102);						g.setColor(Color.blue);						g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+5, ownerModule.getMargin()+100);						g.setColor(Color.black);					}					g.setFont(f);				}			}		}	}	/*.................................................................................................................*/	boolean doWarn = false;	public void addWarning(boolean warn){		doWarn = warn;	}	/*.................................................................................................................*/	public   String infoAtNodes(Tree tree, int drawnRoot) {		return parameters + "\n\nNodes with X, Y positions\n\n" + textPositions.toString();	}	/*.................................................................................................................*/	public   String additionalText(Tree tree, int drawnRoot) {		return parameters;	}	/*.................................................................................................................*/	public   void drawOnTree(Tree tree, int drawnRoot, Graphics g) {		drawImage(treeDisplay, tree, drawnRoot, g);		ownerModule.drawExtras(g,treeDisplay);	}	public   void printOnTree(Tree tree, int drawnRoot, Graphics g) {		drawOnTree(tree, drawnRoot, g);	}	public   void setTree(Tree tree) {	}	public void turnOff() {		super.turnOff();	}}/* ======================================================================== */class NodeLocsLongLatTaxaExtra extends TaxaDisplayBkgdExtra {	NodeLocsLongLat ownerModule;	public boolean pleaseAdjustScrolls = false;	public String parameters = "";	StringBuffer textPositions;	public NodeLocsLongLatTaxaExtra (NodeLocsLongLat ownerModule, TaxaDisplay taxaDisplay) {		super(ownerModule, taxaDisplay);		this.ownerModule = ownerModule;		textPositions = new StringBuffer();		setPlacement(BELOW);//		Image mapImage = ownerModule.getMapImage();//		if (mapImage !=null)//		treeDisplay.setPreferredSize(ownerModule.getMapImage().getWidth(treeDisplay)+ownerModule.getMargin(), ownerModule.getMapImage().getHeight(treeDisplay)+ownerModule.getMargin());	}	/*_________________________________________________*/	public   void drawImage(TaxaDisplay taxaDisplay, Graphics g) { 		Composite composite = null;		if (ownerModule.getFadeMap()) {			composite = ColorDistribution.getComposite(g);			ColorDistribution.setTransparentGraphics(g);		}		//  ((Graphics2D)g).scale(0.5,0.5);		try {		//	g.drawImage(ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(),Color.white, null);			g.drawImage(ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(),taxaDisplay.getFieldWidth(), taxaDisplay.getFieldHeight(), Color.white, null);		}		catch (Exception e) {		}		// MesquiteImage.drawImageWithinRect(g,ownerModule.getMapImage(),ownerModule.getMargin(),ownerModule.getMargin(),(int)(ownerModule.getMapWidth()*0.5), (int)(ownerModule.getMapHeight()*0.5), null);		// ((Graphics2D)g).scale(2.0,2.0);		if (ownerModule.getFadeMap())			ColorDistribution.setComposite(g,composite);				if (!ownerModule.getProjectionTask().getFullySpecified()) {			Font f = g.getFont();			if (f!=null){				Font fontToSet = new Font (f.getName(), Font.BOLD,32);				if (fontToSet!= null) {					g.setFont(fontToSet);					g.setColor(Color.black);					g.drawString("Uncalibrated Projection", ownerModule.getMargin()+7, ownerModule.getMargin()+62);					g.setColor(Color.red);					g.drawString("Uncalibrated Projection", ownerModule.getMargin()+5, ownerModule.getMargin()+60);					g.setColor(Color.black);					GraphicsUtil.setFontSize(14,g);					g.setColor(Color.white);					g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+6, ownerModule.getMargin()+101);					g.setColor(Color.blue);					g.drawString("To calibrate, add latitude-longitude calibration points, then set parameter values of map", ownerModule.getMargin()+5, ownerModule.getMargin()+100);					g.setColor(Color.black);				}				g.setFont(f);			}		}	}	/*.................................................................................................................*/	boolean doWarn = false;	public void addWarning(boolean warn){		doWarn = warn;	}	/*.................................................................................................................*/	public   String infoAtNodes(Tree tree) {		return parameters + "\n\nNodes with X, Y positions\n\n" + textPositions.toString();	}	/*.................................................................................................................*/	public   String additionalText(Tree tree) {		return parameters;	}	/*.................................................................................................................*/	public   void drawOnTaxa(Taxa taxa, Graphics g) {		drawImage(taxaDisplay , g);		ownerModule.drawTaxaExtras(g,taxaDisplay);	}	public   void printOnTaxa(Taxa taxa, Graphics g) {		drawOnTaxa(taxa, g);	}	public   void setTaxa(Taxa taxa) {	}	public void turnOff() {		super.turnOff();	}}